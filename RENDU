           Mini-projet 2 : Synthèse d'invariant en SMT-LIB
                            fichier RENDU

Identité
--------
Nombre de binôme: 47
Nom, prénom 1: Kadem, Hocine
Nom, prénom 2: Dorbane, Sara


Questions sur votre code
------------------------

** Exercice 2 **

0. 
make invariants s'exécute sans erreurs ou warnings : 
-> OUI


./invariants produit une sortie au format SMT-LIB : 
-> 
   ; synthèse d'invariant de programme
   ; on déclare le symbole non interprété de relation Invar
   (declare-fun Invar (Int Int ) Bool)
   ; la relation Invar est un invariant de boucle
   (assert (forall ((x1 Int) (x2 Int)) (=> (and (Invar x1 x2) (< x1 3)) (Invar (+ x1 1) (+ x2 3)))))
   ; la relation Invar est vraie initialement
   (assert (Invar 0 0))
   ; l'assertion finale est vérifiée
   (assert (forall ((x1 Int) (x2 Int)) (=> (and (Invar x1 x2) (>= x1 3)) (= x2 9))))
   ; appel au solveur
   (check-sat-using (then qe smt))
   (get-model)
   (exit)
   
sortie est acceptée par Z3 : 
-> OUI
Z3 renvoie le resultat suivant : 
   sat
   (
   (define-fun Invar ((x!0 Int) (x!1 Int)) Bool
      (or (and (<= 0 x!0)
               (<= 1 x!0)
               (<= 2 x!0)
               (<= 3 x!0)
               (not (= x!1 10))
               (not (= x!1 7))
               (not (= x!1 3))
               (not (= x!1 (- 3)))
               (not (= x!1 8))
               (not (= x!1 11))
               (not (= x!1 0))
               (not (= x!1 (- 2)))
               (not (= x!1 1))
               (not (= x!1 2))
               (not (= x!1 5))
               (not (= x!1 6))
               (not (= x!1 (- 1)))
               (not (= x!1 4))
               (= x!1 9))
         (and (<= 0 x!0)
               (<= 1 x!0)
               (<= 2 x!0)
               (not (<= 3 x!0))
               (not (= x!1 10))
               (not (= x!1 7))
               (not (= x!1 3))
               (not (= x!1 (- 3)))
               (not (= x!1 8))
               (not (= x!1 11))
               (not (= x!1 0))
               (not (= x!1 (- 2)))
               (not (= x!1 1))
               (not (= x!1 2))
               (not (= x!1 5))
               (= x!1 6))
         (and (<= 0 x!0)
               (<= 1 x!0)
               (not (<= 2 x!0))
               (not (= x!1 10))
               (not (= x!1 7))
               (= x!1 3))
         (and (<= 0 x!0)
               (not (<= 1 x!0))
               (not (= x!1 10))
               (not (= x!1 7))
               (not (= x!1 3))
               (not (= x!1 (- 3)))
               (not (= x!1 8))
               (not (= x!1 11))
               (= x!1 0))))
   ) 


---

1. Le type `term` est un type récursif : 

   quel type de fonction est-il naturel d'utiliser ?
   ->Fonctions recursives

   Quels sont vos cas de base ?
   -> les cas de bases sont :
   .t est une variable de type Var a, avec a un entier alors la fonction  retourne une variable xa
   .t est une constante a
   .t est une operation d'addition de type Add(a1,a2), la fonction renvoie le signe de l'addition "+" suivi des termes a1 a2
   .t est une operation de multiplication de type Mult(a1,a2), la fonction renvoie le signe de la multiplication "*" suivi des termes a1 a2

   Quelle quantité strictement décroissante au cours des appels successifs vous assure la terminaison ?
   -> les quantités Var a et Const a assurent la terminaison de la recusrtion car ce sont des cas atomiques

---

2. Pour l'implémentation de `str_condition` : 

   Les fonctions auxiliaires nous avez utilisées et/ou écrites :
   
   * val str_of_term_with_space : term -> string -> string 
      revoie une chaine de caractère qui concatène le caractère " " (espace) avec str_of_term de term, le tout concatèné avec la chaine de caractère reste

      exemple : 
      str_of_term_with_space Var(2) " suite de la formule" renvoie : " x2 suite de la formule"

   * List.fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
      fold_right f [a1; ...; an] init = f a1 (f a2 (... (f an init) ...))

   utilisation :
   on l'appelle avec les arguments suivants : List.fold_right str_of_term_with_space l ""
   ceci permet de générer une chaine de caractère des termes que contient la liste l, tous séparés avec un espace (le caractère " ")

---

3. Pour l'implémentation de `str_assert_forall` : 

   Les fonctions auxiliaires nous avez utilisées et/ou écrites :
   
   * tr_assert_forall_aux : int -> int -> string
      tr_assert_forall_aux n k renvoie : "(xk Int) (xk+1 Int) .... (xn Int)"

      la fonction tr_assert_forall_aux est une fonction récursive où chaque iteration renvoie la chaine de caractère ("term_string Int ") où term_string represente la chaine de caractère de term

      elle prend en paramètre deux int et renvoie un string 
      le premier int represente le nombre de terme total
      le deuxième int represente a partir de quel terme on va remplir le string de retour

      remarque : 
      lors de l'envoie du dernier term (les deux paramètre en entrés sont egaux) on ajoute pas le caractère " " (espace)

      exemple : 
      tr_assert_forall_aux 5 3 renvoie : "(x3 Int) (x4 Int) (x5 Int)"

      utilisation :
      on l'appelle de cette façon : str_assert_forall_aux n 1 pour renvoyer un string qui contient du terme x1 jusqu'a xn


---

4. Le langage de programmation WA suppose que les mises à jour des
   variables `x1`, ..., `xk` sont simultanées : par exemple, si `x1`
   vaut `1` et x2 vaut `1`, exécuter

   x1 = x2 + 1;
   x2 = x1 + 1;

   résulte en `x1` valant `2` et `x2` valant `2`. En Java, les mises à
   jour sont séquentielles et le résultat serait que `x1` vaudrait `2`
   et `x2` vaudrait `3`. Expliquez en français comment modifier le
   code pour construite un programme SMT-LIB plus proche de la façon
   dont les variables sont mises à jour en Java.

**à remplir**

---
5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

.MODIF QST1
.FAIRE QST4 ET QST5 
.COMMENTER SMTLIB
.CODER QST5 DANS INVARIANTS.ML
