           Mini-projet 2 : Synthèse d'invariant en SMT-LIB
                            fichier RENDU

Identité
--------
Nombre de binôme: 47
Nom, prénom 1: Kadem, Hocine
Nom, prénom 2: Dorbane Sara


Questions sur votre code
------------------------

** Exercice 2 **

0. 
`make invariants` s'exécute sans erreurs ou warnings : 
->

`./invariants` produit une sortie au format SMT-LIB : 
-> ; synthèse d'invariant de programme
   ; on déclare le symbole non interprété de relation Invar
   (declare-fun Invar (Int Int ) Bool)
   ; la relation Invar est un invariant de boucle
   TODO
   ; la relation Invar est vraie initialement
   (assert (Inv 0 0))
   ; l'assertion finale est vérifiée
   TODO
   ; appel au solveur
   (check-sat-using (then qe smt))
   (get-model)
   (exit)


sortie est acceptée par Z3 : 
->

---

1. Le type `term` est un type récursif : 

   quel type de fonction est-il naturel d'utiliser ?
   ->

   Quels sont vos cas de base ?
   ->

   Quelle quantité strictement décroissante au cours des appels successifs vous assure la terminaison ?
   ->

---

2. Pour l'implémentation de `str_condition` : 

   Les fonctions auxiliaires nous avez utilisées et/ou écrites :
   
   * val str_of_term_with_space : term -> string -> string 
      revoie une chaine de caractère qui concatène le caractère " " (espace) avec str_of_term de term, le tout concatèné avec la chaine de caractère reste

      exemple : 
      str_of_term_with_space Var(2) " suite de la formule" renvoie : " x2 suite de la formule"

   * List.fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
      fold_right f [a1; ...; an] init = f a1 (f a2 (... (f an init) ...))

   utilisation :
   on l'appelle avec les arguments suivants : List.fold_right str_of_term_with_space l ""
   ceci permet de générer une chaine de caractère des termes que contient la liste l, tous séparés avec un espace (le caractère " ")

---

3. Pour l'implémentation de `str_assert_forall` : 

   Les fonctions auxiliaires nous avez utilisées et/ou écrites :
   
   * tr_assert_forall_aux : int -> int -> string
      tr_assert_forall_aux n k renvoie : "(xk Int) (xk+1 Int) .... (xn Int)"

      la fonction tr_assert_forall_aux est une fonction récursive où chaque iteration renvoie la chaine de caractère ("term_string Int ") où term_string represente la chaine de caractère de term

      elle prend en paramètre deux int et renvoie un string 
      le premier int represente le nombre de terme total
      le deuxième int represente a partir de quel terme on va remplir le string de retour

      remarque : 
      lors de l'envoie du dernier term (les deux paramètre en entrés sont egaux) on ajoute pas le caractère " " (espace)

      exemple : 
      tr_assert_forall_aux 5 3 renvoie : "(x3 Int) (x4 Int) (x5 Int)"

      utilisation :
      on l'appelle de cette façon : str_assert_forall_aux n 1 pour renvoyer un string qui contient du terme x1 jusqu'a xn


---

4. Le langage de programmation WA suppose que les mises à jour des
   variables `x1`, ..., `xk` sont simultanées : par exemple, si `x1`
   vaut `1` et x2 vaut `1`, exécuter

   x1 = x2 + 1;
   x2 = x1 + 1;

   résulte en `x1` valant `2` et `x2` valant `2`. En Java, les mises à
   jour sont séquentielles et le résultat serait que `x1` vaudrait `2`
   et `x2` vaudrait `3`. Expliquez en français comment modifier le
   code pour construite un programme SMT-LIB plus proche de la façon
   dont les variables sont mises à jour en Java.

**à remplir**

---
5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**


